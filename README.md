| Лабораторная работа №1.2 | 24.Б10                    | Архитектура компьютера |
| :----------------------- | ------------------------- | ---------------------- |
| Числа с плавающей точкой | Кашенин Андрей Дмитриевич | 2025                   |

## Полное условие

Полное условие лежит [тут](/МКН%20АК%2025.%20ЛР1.1%20Фикс.%20точка.pdf)

## Инструментарий

- CLang 18 версии
- С++ 23 стандарта

## Что реализовано

Была реализована вся логика, указанная в тз, а именно нижеуказанные операции:

- Сложение
- Разность
- Деление
- Умножение
- mad
- fma

с такими округлениями:

- округление к 0
- Округление к +inf
- Округление к -inf
- Округление к ближайшему чётному

Всё это для чисел с плавающей точкой в форматах single и half precision в соответствии со стандартом IEEE-754

# Описание

main.cpp

Более подробные описания всех классов и методов ниже. Тут лишь примерные слова о том что они делают.

1. Мне не нравится работать с char\*\*, поэтому я перевожу argv в vector из string.
2. Далее статический метод класса Parser parse_input_query возвращает мне InputQuery, в которой собраны входные данные
3. Создаётся класс ExpressionHolder, цель которого - хранить InputQuery и выполнить операцию в нём.
4. Вызывается метод solve_and_return_ans, который собственно и должен посчитать ответ и вернуть его в виде строки

Важное замечание: Мне показалось более правильным, если при пробрасывании исключения буддут известны как текст ошибки, так и код ошибки, поэтому я написал свой класс MyException.
Ещё одно важное замечание: Я в лабораторной работе везде с int64, чтобы меньше думать о переполнениях

## 0. My_exception.hpp и My_exception.cpp

### Назначение

Содержат реализацию класса MyException, которая нужна для хранения сообщения текста ошибки + кода ошибки. Мне показалось что это может быть полезно(хранение кода ошибки), но в итоге я всё равно завершаюсь с кодом 1. Внутри это просто класс с 2 приватными полями: \_code(типа int) и \_error(типа string) и геттерами на их получение.

EXIT_FAILURE это просто define на 1 из cstdlib

## 1. i_possible_float_numbers.hpp и i_possible_float_numbers.cpp

Тут лежат 2 очень важных класса: NormalFloatNumerHandler и PossibleFloat.
NormalFloatNumerHandler - это класс, который содержит в себе именно нормализованную форму флота. Там есть соответственно 3 поля на знак, нормализованную экспоненту и мантиссу.
PossibleFloat - один из главных классов этой программы.
Он хранит собственно число с плавающей точкой в таком формате - число int64, хранящее число, количество бит на мантиссу и экспоненту.
В нём куча методов: геттеры всего, сеттеры всего, create\_ возвращает PossibleFloat, который указан в сигнатуре, check - это проверки на что-то(check if nan возвращает пару, потому что число может измениться после проверки. Например именно там я "утихомириваю" сигнальный nan)
Логика каждого метода ясна по его сигнатуре

## 2. input_query.hpp и input_query.cpp

### Назначение

Содержат основную информацию о входных значениях, а так же класс InputQuery, цель которого просто абсорбировать входные данные. Информация об округлениях и операциях в соответствующих enum классах: PossibleOperations и PossibleRounding. В InputQuery приватные поля и их геттеры на входные данные:

- \m_first_number(первое дробное число в нужном формате),
- \m_second_number(второе дробное число),
- \m_third_number(третье по операции число),
- \m_cur_rounding(текущее округление. Тип - PossibleRounding),
- \m_cur_operation(текущая операция. Тип - PossibleOperations. Если операции нет, то PossibleOperations::NO_OPER)

Данные при этом тут никак не обрабатываются с точки зрения логики программы
В конструкторе класса значения просто присваиваются полям

## 3. parser.hpp и parser.cpp

### Назначение

Содержат один класс - parser, цель которого из вектора строк получить InputQuery. Для этого в нём есть методы:

- parse_input_query - Собственно он и должен принимать на вход вектор строк и возвращать InputQuery.

```C++
InputQuery parse_input_query(const std::vector<std::string>&& argv);
```

- parse_to_int - этот метод принимает строку и базу СИ, после чего переводит строку в число по данному основанию.

```C++
  std::int64_t parse_to_int(const std::string& inpStr, std::int64_t base)
```

Теперь по реализации:

#### parse_to_int

Использует стандартную функцию std::stoul, которая переводит число из строки в uint64 по нужной базе. \

```C++
std::uint64_t pos = 0;
std::uint64_t result = std::stoul(inpStr, &pos, base);
```

Дальше идёт проверка что прочитали всю строку(останавливается на символе, если он не парсится).

#### parse_input_query

Этот метод должен только распарсить данные из строковых в InputQuery. Сначала в нём проверка на количество входных данных. \
Далее просто происходит парсинг входных аргументов несколькими ифами(сначала в зависимости от формата ставлю количество ббит на мантиссу и экспоненту, потом окргуления и т.д.)
Числа из hex паршу с помощью parse_to_int

## 3. expression_holder.hpp и expression_holder.cpp

### Назначение

В этих файлах лежит вся непосредственная логика программы. Т.е. то что будет происходить с данными. \

- get_all_ones_at_inp_bit_cnt - Вспомогательная функция, возвращающая число типа std::uint64, у которого на младших inpCnt(входной параметр) битах единицы

```C++
std::uint64_t get_all_ones_at_inp_bit_cnt(std::int64_t inpCnt);
```

- cut_number - принимает число и сколько надо обрезать. Она не просто берёт cnt_bits младших битов, но так же дополняет "обрезанное число" до 64 бит, т.е. множит старший разряд(чтобы было дополнение до 2-x)

```C++
std::int64_t cut_number(std::int64_t inpNumber, std::int64_t cnt_bits);
```

Самый главный класс этой программы: Expression_Holder. Сначала пройдёмся по полям:

- \m_curInpQuery - это просто поле, содержащее пришедшую InputQuery

```C++
InputQuery m_curInpQuery;
```

Теперь методы:

- Конструктор(просто принимает InputQuery)
- solve_and_return_ans - как понятно из названия, должен выполнить что нужно и вернуть ответ-строку

```C++
std::pair<std::string, std::string> solve_and_return_ans();
```

- use_oper - применяет операцию, если она есть, и возвращает ответ - PossibleFloat

```C++
PossibleFloat use_oper();
```

- round_to_bin_and_shift - во время лабораторной я довольно часто должен сдвигать число на сколько-то бит вправо и при этом правильно округлять. Это и делает этот метод: сдвигает, округляет и возвращает полученное число. Знак нужен для правильных округлений, зависящих от знака входного числа

```C++
std::uint64_t round_to_bin_and_shift(std::uint64_t inpValue,
                                         std::uint64_t cntOfBits,
                                         std::uint64_t sign);
```

- divide_int - Аналог метода divide из предыдущей лабораторной(1.1). Он должен поделить первое число на второе. Опять же информацию о знаке я в числе получить не могу => передаю информацию о знаке. Так же нам не всегда нужно применять сдвиг числителя(во избежание переполнений), поэтому я передаю нужно ли сдвинуть и, если да, то насколько(тут криво написано, знаю, но если я пишу true, то я не забываю передать и нужный shift. Немного небезопасно и костыльно).

```C++
std::uint64_t divide_int(std::uint64_t big_first_numb,
                             std::uint64_t big_second_numb, std::uint64_t sign,
                             bool should_shift_numer = true,
                             std::uint64_t shift = 0);
```

- divide
- mult
- plus
- minus
- fma
- mad
  Эти методы - и есть операции, которые надо выполнить над PossibleFloat
- inf_max_checks - если число слишком большое, возвращает чтем оно должно быть в зависимости от округлений
- \*\_checks - это методы проверок входных аргументов операций. И они возвращают {true, ans_float}, если результат выполнения этих операций тривиален и не требует дальнейшей работы операции. Например: \
- Отсекаются nan
- Отсекаются бесконечности
- Иногда отсекаются и нули. Например 0 _inf или 0_ {finite}

```C++
static std::pair<bool, PossibleFloat>
    divide_checks(PossibleFloat first_float, PossibleFloat second_float);
```

Эти методы нужны для того, чтобы я был уверен, что работаю с валидными числами. Т.е. с денормализованными или нормализованными.

- format_big_number_to_mant_format - это один из методов-костылей. Он принимает inp_number в формате 1{mant} << mant_bit_cnt, экспоненту и знак и должен вернуть пару: Правильно приведённую мантиссу и полученную экспоненту
-

```C++
std::pair<std::uint64_t, std::int64_t> format_big_number_to_mant_format(
        std::uint64_t inp_number, std::uint64_t mant_cnt, std::uint64_t sign);
```

- format_int_exp_and_sign_to_possible_float - этот метод должен установить мантиссу и экспоненту в ans_float. Это тоже псевдо-костыльный метод. Он отличается от предыдущего тем, что нам, возможно, нужно представить бОльшее число как мантиссу и при этом сдвинуть экспоненту. В частности мне нужно было это для умножения, где получается денормализованный ответ. Тогда у меня получалось 2 округления. Именно поэтому нужны 2 последних поля - крайние случаи где сдвиг может быть 2 и более раз

```C++
void format_int_exp_and_sign_to_possible_float(
        PossibleFloat& ans_float, std::uint64_t mant, std::int64_t exp,
        bool should_work_with_prev_big_number = false,
        std::uint64_t prev_big_number = 0, std::uint64_t added_shift = 0);
```

- format_to_output - должен отформатировать флот в пару строк для ответа

## Реализация

Теперь пройдёмся по реализации ExpressionHolder

#### 1. get_all_ones_at_inp_bit_cnt

Если количество бит на которых должны быть 1 >= 64, можно заметить, что ответ - просто ~0 \
Иначе Можно не боясь переполнения сдвинуть единицу на inpCnt и вычесть единицу

## 3. ExpressionHolder

Теперь сам класс ExpressionHolder:

### 1. Конструктор

Просто присваивает приватному полю значение

### 2. solve_and_return_ans

Проверяет, нужно ли выполнить операцию и, если нужно, то вызывет use_oper
Потом вызывет форматирование ответа

### 4. round_to_bin_and_shift

В этой реализации в этот метод может прийти очень большое значение. Для начала я проверяю, не 0 ли входное число \
Потом проверка, если сдвиг очень большой. Тогда в зависимости от округлений и знака ответ либо 0, либо 1
Потом вызов divide_int

```C++
std::int64_t ExpressionHolder::round_to_bin_and_shift(std::int64_t inpValue,
                                                      std::int64_t cntOfBits) {
    return divide(inpValue, 1LL << cntOfBits, false);
}
```

### 5. use_oper

Тут просто switch case со всеми возможными операциями и возврат ответа

### 6. divide_int

Метод целочисленного деления с округлениями. Но только я живу в инварианте, что входные значения неотрицательны => я обрезал метод из предыдущей лабораторной на деление только неотрицательных. В принципе просто сначала находим частное при делении с окргулением к 0, потом через switch case выбираем, в каких случаях нужно прибавить 1

### 7. divide

Для начала, как и во всех методах операций, я делаю проверки вызовом divide_check. Пототм привожу к нормальной форме. Создаю число-ответ такого же формата и присваиваю ему знак(тут знак определён однозначно). Дальше привожу числа к их "фактическим" формам мантисс. Идея деления простая. Нужно чтобы знаменатель был > 0.5 \* числитель и <= числителя. Тогда при делении их как чисел с фиксированной точкой в формате 1.{...} получится число от 1 до 2, что нам и надо. Мне в моём формате достаточно при необходимости умножить на 2 числитель. Потом я просто делю и если получилось не денормализованное число, то ответ найден. В противном случае надо сдвинуть влево знаменатель, чтобы немного уменьшить частное, при этом сохранив окргуления. Так я получу буквально значение мантиссы(экспонента по дефолту 0)

### 8. mult

mult - буквально частный случай fma. Поэтому я буквально применил fma к first_float, second_float и zero. Однако из-за округлений у нас могполучиться неправильный знак(сумма с 0 могла подпортить его. Например проблема что 0 после суммы при округлении к -inf всегда -0). Однако знак умножения однозначен, поэтому я после этого ручками поставил знак ответа

### 9. minus

Просто вызывает plus от числа с противоположным знаком

### 10. plus

Эту операцию я делал через длинную арифметику. Соответственно сначала находится максимальное по модулю число, потом эти числа представляются в формате {some_big_numb} \* 2 ^ -(get_mant_cnt + get_exp_bias). В общем приводятся к самому минимальному множителю. Вот с этими some_big_numb я и работаю. Складываю или вычитаю в зависимости от знака, а потом вызываю format_to_float, который приводит bigint к PossibleFloat(пояснение длинной арифметики позже). Ифы на проверку 0 связаны со старндартом. Там если получился 0, то при округлении к -inf будет -0.

### 11. mad

Прост вызов 2 методов

### 12. fma

Вот тут уже поприкольнее. Я так же как и в сложении привожу первое и второе число к формату {some*big_numb} \_2 ^ -(get_mant_cnt + get_exp_bias). Потом умножаю числа some_big_numb. Но тогда у меня получилось число в формате {some_big_numb}* 2 ^ -2(get_mant_cnt + get_exp_bias). Поэтому я привожу третье число тоже к такому формату, а потом складываю. При этом никаких доп округлений нет, т.к. это длинная арифметика и никакая информация не теряется. После суммы я вызываю метод format_to_float_with_different_base. Он почти такой же, как и format_to_float, но только говорит что по факту BigInt может означать другое дробное с другим основанием(в нашем случае -2 \* (get_mant_cnt + get_exp_bias)), поэтому я и передаю доп сдвиг, который нужно учитывать при округлениях и приведении числа
Потом проверка нулей

### 13. \*\_checks

Тут даже говорить нечего. Просто какие-то ифы на крайние случаи

### 14. format_int_exp_and_sign_to_possible_float

Если экспонента в пределах, то просто ставит числу экспоненту и мантиссу.
Если большая, то вызывает inf_max_checks. Если экспонента слишком маленькая, то сдвигает число на нужное количество бит.

### 15. format_big_number_to_mant_format

В принципе просто проверки и сдвиг, если надо, а так же аккуратно посчитанная реальная экспонента с учётом того, в каком формате приходит входная мантисса (1{mant_bits} << mant_cnt)

### inf_max_checks

Просто switch case на разные знаки и округления

## 4. big_int.hpp

Я даже не знаю что тут говорить. Просто длинная арифметика на битсетах. Операции все понятны. Наверное стоит лишь пояснить 2 метода:

### 1. format_to_float

Вызывает format_to_float_with_different_base c доп сдвигом 0 и возвращает bool: true, если после сдвига и округлений убранный "хвост" != 0. Это нужно для аккуратной работы с 0

### 2. format_to_float_with_different_base

Напомню что делает этот метод. Он принимает по ссылке флоат, куда нужно записать данные, округление и доп базу. Доп база - это разница по модулю между базой числа, которым явзяется BigInt и которое может представить флоат. \
Сначала банальные проверки что число 0. \
Потом tmp_fract_slice - это буквально доп информация из длинного числа, которую нужно учитывать при округлениях. Я её запоминаю и сдвигаю большое число так, чтобы его база равнялась базе флота(под базой я подразумеваю минимально возможное по модулю положительное число, которое можно закодировать). А потом просто начинаю работать уже с этим числом: \

- Нахожу последнюю единицу
- Если она очень близко, значит наше число денормализованное => округляю число в зависимости от хвоста в tmp_fract_slice и пишу округлённое число в inp_float(возможно такое, что после прибавления единицы число стало нормализованным. Тогда я пишу его форму(а именно могло стать только 1.000...000))
- Потом нахожу вторую часть части, которую нужно учитывать при окргулении - fract_slice. Нахожу её, а потом приписываю fract_slice чтобы работать с ней для валидных округлений.
- Опять же нахожу экспоненту, режу мантиссу
- А потом просто switch case с проверками на округления
- В конце проверяю не вышел ли я за границы мантиссы
- Дальше просто провека, не получил ли я случайно большое число
  Потом я просто ставлю на позиции мантиссу и экспоненту и всё

Этот метод возвращает bool: true, если после сдвига и округлений убранный "хвост" != 0. Это нужно для аккуратной работы с 0
